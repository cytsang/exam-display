<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SPSLT Exam Display</title>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7f9;
      --border:#d9dde3;
      --text:#111827;
      --muted:#9aa3af;
      --radius:18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "PingFang HK", "Noto Sans TC", Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .wrap{
      min-height: 100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 24px;
    }

    .stage{
      width: min(1100px, 100%);
      display:flex;
      gap: 28px;
      align-items:center;
    }

    /* LEFT */
    .clockShell{
      flex: 1 1 60%;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .clockCircle{
      width: min(560px, 68vw);
      aspect-ratio: 1 / 1;
      border: 10px solid #2563eb;         /* blue border */
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 12px 30px rgba(37,99,235,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 16px;
      position: relative;
    }

    .face{
      width: 100%;
      height: 100%;
      border-radius: 999px;
      position: relative;
      background:
        radial-gradient(circle at center, rgba(0,0,0,.06) 0 2px, transparent 3px),
        radial-gradient(circle at center, rgba(0,0,0,.04) 0 55%, transparent 56%),
        #fff7cc; /* pale yellow */
    }

    /* marks */
    .mark{
      position:absolute;
      left:50%;
      top:50%;
      width: 7px;
      height: 22px;
      background: rgba(17,24,39,.70);
      border-radius: 6px;
      transform: translate(-50%, -50%) rotate(0deg) translateY(-46%);
      z-index: 1;
    }
    .mark.minor{
      width: 3px;
      height: 12px;
      background: rgba(17,24,39,.22);
      border-radius: 6px;
    }

    /* numbers 1-12 */
    .num{
      position:absolute;
      transform: translate(-50%, -50%);
      font-variant-numeric: tabular-nums;
      font-weight: 850;
      font-size: clamp(18px, 2.2vw, 26px);
      color: rgba(17,24,39,.78);
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 0 rgba(255,255,255,.6);
      z-index: 2;
    }

    /* hands */
    .hand{
      position:absolute;
      left:50%;
      top:50%;
      transform-origin: 50% 100%;
      border-radius: 999px;
      transform: translate(-50%, -100%) rotate(0deg);
      box-shadow: 0 6px 14px rgba(0,0,0,.08);
      z-index: 4;
    }
    .hand.hour{
      width: 14px;
      height: 30%;
      background: rgba(17,24,39,.90);
    }
    .hand.minute{
      width: 10px;
      height: 42%;
      background: rgba(17,24,39,.82);
    }
    .hand.second{
      width: 3px;
      height: 48%;
      background: rgba(220,38,38,.95);
      box-shadow: none;
      z-index: 6;
    }

    .hub{
      position:absolute;
      left:50%;
      top:50%;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      transform: translate(-50%,-50%);
      background: rgba(17,24,39,.96);
      box-shadow: 0 2px 10px rgba(0,0,0,.18);
      z-index: 7;
    }
    .hub::after{
      content:"";
      position:absolute;
      inset: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,.18);
    }

    .readout{
      position:absolute;
      left:50%;
      bottom: 7%;
      transform: translateX(-50%);
      text-align:center;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(246,247,249,.88);
      backdrop-filter: blur(6px);
      min-width: 240px;
      z-index: 8;
    }
    .digital{
      font-variant-numeric: tabular-nums;
      font-weight: 850;
      font-size: 24px;
      letter-spacing: .5px;
    }
    .status{
      margin-top: 4px;
      font-size: 12px;
      color: #6b7280;
    }

    /* RIGHT (dynamic groups) */
    .side{
      flex: 0 0 min(520px, 100%);
      display:flex;
      flex-direction:column;
      gap: 16px;
      height: min(520px, 70vh);
      position: relative;

      /* dynamic font sizes controlled by JS */
      --mainFont: 50px;
      --timeFont: 30px;
    }

    .groups{
      flex: 1;
      display:flex;
      flex-direction:column;
      gap: 18px;
      min-height: 0;
      padding-right: 70px; /* space for + button */
    }

    .group{
      flex: 1;
      display:flex;
      flex-direction:column;
      gap: 14px;
      min-height: 0;
      position: relative; /* for delete button */
    }

    .field{
      background: var(--panel);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 8px 18px rgba(0,0,0,.05);
      padding: 14px 16px;
      display:flex;
      overflow:hidden;
      min-height: 0;
    }

    /* height ratio 5:4 inside each group */
    .field.main { flex: 5; }
    .field.time { flex: 4; }

    /* multi-line main */
    .field.main textarea{
      width:100%;
      height:100%;
      border:0;
      outline:none;
      background:transparent;
      color: var(--text);
      font-size: var(--mainFont);
      font-weight: 850;
      letter-spacing: .2px;
      line-height: 1.08;
      resize: none;
      padding: 2px 2px;
      overflow: hidden; /* keep clean */
    }

    /* time (single line) */
    .field.time input{
      width:100%;
      height:100%;
      border:0;
      outline:none;
      background:transparent;
      color: var(--text);
      font-size: var(--timeFont);
      font-weight: 850;
      letter-spacing: .2px;
      padding: 2px 2px;
    }

    .field textarea::placeholder,
    .field input::placeholder{
      color: var(--muted);
      font-weight: 750;
    }

    /* plus button */
    .addBtn{
      position:absolute;
      right: 8px;
      bottom: 8px;
      width: 54px;
      height: 54px;
      border-radius: 999px;
      border: 2px solid var(--border);
      background: #ffffff;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      font-size: 34px;
      line-height: 1;
      font-weight: 900;
      cursor: pointer;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .addBtn:active{ transform: translateY(1px); }
    .addBtn[disabled]{ opacity:.45; cursor:not-allowed; }

    /* delete button per group */
    .delBtn{
      position: absolute;
      right: 10px;
      top: 10px;
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 2px solid var(--border);
      background: #ffffff;
      box-shadow: 0 8px 16px rgba(0,0,0,.10);
      font-size: 22px;
      font-weight: 900;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index: 10;
    }
    .delBtn:active{ transform: translateY(1px); }

    @media (max-width: 900px){
      .stage{ flex-direction:column; }
      .side{ width: min(560px, 100%); height: min(520px, 55vh); }
      .clockShell{ width: 100%; }
      .groups{ padding-right: 0; }
      .addBtn{ right: 12px; bottom: 12px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage">

      <!-- LEFT clock -->
      <div class="clockShell">
        <div class="clockCircle">
          <div class="face" id="face">
            <div class="hand hour" id="hHand"></div>
            <div class="hand minute" id="mHand"></div>
            <div class="hand second" id="sHand"></div>
            <div class="hub"></div>

            <div class="readout">
              <div class="digital" id="digital">--:--:--</div>
              <div class="status" id="syncStatus">Syncing…</div>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT dynamic textbox groups -->
      <div class="side" id="side">
        <div class="groups" id="groups">
          <!-- Group 1 -->
          <div class="group">
            <button class="delBtn" type="button" aria-label="Delete this pair">×</button>

            <div class="field main">
              <textarea class="mainInput" rows="2" placeholder="Level / Subj / Paper"></textarea>
            </div>

            <div class="field time">
              <input class="timeInput" type="text" placeholder="Time">
            </div>
          </div>
        </div>

        <button class="addBtn" id="addBtn" type="button" aria-label="Add another pair">＋</button>
      </div>

    </div>
  </div>

  <script>
    // ====== Build marks + numbers ======
    const face = document.getElementById("face");

    for (let i = 0; i < 60; i++){
      const isHour = (i % 5 === 0);
      const d = document.createElement("div");
      d.className = "mark" + (isHour ? "" : " minor");
      d.style.transform = `translate(-50%, -50%) rotate(${i * 6}deg) translateY(-46%)`;
      face.appendChild(d);
    }

    // numbers 1..12 (trig positioning)
    const R = 44;
    for (let n = 1; n <= 12; n++){
      const angle = (n * 30 - 90) * Math.PI / 180;
      const x = 50 + R * Math.cos(angle);
      const y = 50 + R * Math.sin(angle);

      const el = document.createElement("div");
      el.className = "num";
      el.textContent = String(n);
      el.style.left = x + "%";
      el.style.top  = y + "%";
      face.appendChild(el);
    }

    // ====== Online sync via Apps Script ======
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbydFg6fSuA9KQn5ZY42PRn2t09tq2Kqbrsv3TlqDPIVyNpNEadheHSmr3t2bZGxONEh/exec";
    const TZ = "Asia/Hong_Kong";

    const hHand = document.getElementById("hHand");
    const mHand = document.getElementById("mHand");
    const sHand = document.getElementById("sHand");
    const digital = document.getElementById("digital");
    const syncStatus = document.getElementById("syncStatus");

    let offsetMs = 0;
    let onlineSynced = false;

    const digitalFmt = new Intl.DateTimeFormat("en-GB", {
      timeZone: TZ,
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    });

    function hkParts(date){
      const parts = new Intl.DateTimeFormat("en-GB", {
        timeZone: TZ,
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      }).formatToParts(date);

      return {
        hh: Number(parts.find(p => p.type === "hour").value),
        mm: Number(parts.find(p => p.type === "minute").value),
        ss: Number(parts.find(p => p.type === "second").value),
      };
    }

    function render(epochMs){
      const d = new Date(epochMs);
      digital.textContent = digitalFmt.format(d);

      const {hh, mm, ss} = hkParts(d);
      const hour12 = hh % 12;
      const ms = d.getMilliseconds();
      const secFloat = ss + ms / 1000;

      const secDeg = secFloat * 6;
      const minDeg = (mm + secFloat/60) * 6;
      const hourDeg = (hour12 + mm/60 + secFloat/3600) * 30;

      sHand.style.transform = `translate(-50%, -100%) rotate(${secDeg}deg)`;
      mHand.style.transform = `translate(-50%, -100%) rotate(${minDeg}deg)`;
      hHand.style.transform = `translate(-50%, -100%) rotate(${hourDeg}deg)`;
    }

    function tick(){
      render(Date.now() + offsetMs);
    }

    async function syncOnce(){
      try{
        syncStatus.textContent = "Syncing (online)…";
        const t0 = performance.now();
        const res = await fetch(SCRIPT_URL, { cache: "no-store" });
        if(!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        if(typeof data.epochMs !== "number") throw new Error("Missing epochMs");

        const serverEpoch = data.epochMs;
        const t1 = performance.now();
        const rtt = (t1 - t0);
        const approxLocalAtMid = Date.now() - (rtt / 2);

        offsetMs = serverEpoch - approxLocalAtMid;
        onlineSynced = true;
        syncStatus.textContent = "Online synced ✓";
      }catch(e){
        syncStatus.textContent = onlineSynced ? "Sync failed (keeping last sync)" : "Offline fallback (device clock)";
      }
    }

    (async () => {
      await syncOnce();
      tick();
      setInterval(tick, 1000);
      setInterval(syncOnce, 5 * 60 * 1000);
    })();

    // ====== Smart groups: max 3, delete, auto font sizing ======
    const MAX_GROUPS = 3;

    const sideEl = document.getElementById("side");
    const groupsEl = document.getElementById("groups");
    const addBtn = document.getElementById("addBtn");

    // Desired max when only 1 group
    const MAX_MAIN_FONT = 50;
    const MAX_TIME_FONT = 30;

    // Keep ratio close to your 50:30 = 5:3 (time/main = 0.6)
    const TIME_RATIO = 0.60;

    // Lower bounds (so it won't become unreadable)
    const MIN_MAIN_FONT = 20;
    const MIN_TIME_FONT = 14;

    function groupCount(){
      return groupsEl.querySelectorAll(".group").length;
    }

    function refreshAddButtonState(){
      addBtn.disabled = groupCount() >= MAX_GROUPS;
    }

    function clearGroupInputs(groupEl){
      const ta = groupEl.querySelector("textarea");
      const ti = groupEl.querySelector("input");
      if (ta) ta.value = "";
      if (ti) ti.value = "";
      if (ta) ta.focus();
    }

    function attachDeleteHandler(groupEl){
      const del = groupEl.querySelector(".delBtn");
      if (!del) return;

      del.addEventListener("click", () => {
        const n = groupCount();
        if (n <= 1){
          clearGroupInputs(groupEl);
          return;
        }
        groupEl.remove();
        updateSmartLayout();
      });
    }

    function createGroup(){
      const group = document.createElement("div");
      group.className = "group";
      group.innerHTML = `
        <button class="delBtn" type="button" aria-label="Delete this pair">×</button>
        <div class="field main">
          <textarea class="mainInput" rows="2" placeholder="Level / Subj / Paper"></textarea>
        </div>
        <div class="field time">
          <input class="timeInput" type="text" placeholder="Time">
        </div>
      `;
      attachDeleteHandler(group);
      return group;
    }

    addBtn.addEventListener("click", () => {
      if (groupCount() >= MAX_GROUPS) return;
      const g = createGroup();
      groupsEl.appendChild(g);
      updateSmartLayout();
      const ta = g.querySelector("textarea");
      if (ta) ta.focus();
    });

    // Attach delete handler for initial group
    groupsEl.querySelectorAll(".group").forEach(attachDeleteHandler);

    function pxToNum(px){
      const n = Number(String(px).replace("px",""));
      return Number.isFinite(n) ? n : 0;
    }

    function getInnerHeight(el){
      // clientHeight includes padding; we subtract padding to get content box height
      const cs = getComputedStyle(el);
      const pt = pxToNum(cs.paddingTop);
      const pb = pxToNum(cs.paddingBottom);
      return Math.max(0, el.clientHeight - pt - pb);
    }

    function computeMaxFontForOneLine(fieldEl, lineHeightMultiplier){
      // Ensure at least one line is fully visible without clipping
      const innerH = getInnerHeight(fieldEl);
      // textarea/input has its own padding (2px top/bottom) inside; be safe:
      const safety = 6;
      const usable = Math.max(0, innerH - safety);
      return Math.floor(usable / lineHeightMultiplier);
    }

    function updateSmartLayout(){
      refreshAddButtonState();

      // Let layout settle (important after add/remove)
      requestAnimationFrame(() => {
        const groups = Array.from(groupsEl.querySelectorAll(".group"));
        if (groups.length === 0) return;

        // Use the smallest (most constrained) heights
        let minMainField = Infinity;
        let minTimeField = Infinity;

        for (const g of groups){
          const mainField = g.querySelector(".field.main");
          const timeField = g.querySelector(".field.time");
          if (mainField) minMainField = Math.min(minMainField, mainField.clientHeight);
          if (timeField) minTimeField = Math.min(minTimeField, timeField.clientHeight);
        }

        // Compute height-based max font sizes (smart)
        // main textarea line-height ~ 1.08
        // time input line-height ~ 1.10 (close enough)
        const mainHeightMax = computeMaxFontForOneLine(groups[0].querySelector(".field.main"), 1.08);
        const timeHeightMax = computeMaxFontForOneLine(groups[0].querySelector(".field.time"), 1.10);

        // Start from the target maxima, then clamp to what height allows.
        let main = Math.min(MAX_MAIN_FONT, mainHeightMax);
        // Keep ratio for time, but also respect time field height.
        let time = Math.min(MAX_TIME_FONT, Math.floor(main * TIME_RATIO), timeHeightMax);

        // If time got limited by its own height too much, also reduce main to keep balance.
        // (Optional, but helps if time field is very short.)
        const impliedMainFromTime = Math.floor(time / TIME_RATIO);
        main = Math.min(main, impliedMainFromTime);

        // Lower bounds
        main = Math.max(MIN_MAIN_FONT, main);
        time = Math.max(MIN_TIME_FONT, time);

        sideEl.style.setProperty("--mainFont", main + "px");
        sideEl.style.setProperty("--timeFont", time + "px");
      });
    }

    // Update on resize/orientation changes
    window.addEventListener("resize", updateSmartLayout);

    // Initial layout
    updateSmartLayout();
  </script>
</body>
</html>
